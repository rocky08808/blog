[{"title":"学习书籍","date":"2022-04-22T04:26:17.000Z","url":"/blog/2022/04/22/book/","tags":[["javascript","/blog/tags/javascript/"],["react","/blog/tags/react/"],["干货","/blog/tags/%E5%B9%B2%E8%B4%A7/"],["学习书籍","/blog/tags/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/"]],"categories":[["学习书籍","/blog/categories/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D/"]],"content":"JavaScript高级程序设计第4版.pdfES6 入门教程react 小书"},{"title":"js 进阶问题","date":"2022-04-22T04:17:22.000Z","url":"/blog/2022/04/22/jsInterview2/","tags":[["javascript","/blog/tags/javascript/"],["干货","/blog/tags/%E5%B9%B2%E8%B4%A7/"]],"categories":[["javascript","/blog/categories/javascript/"]],"content":"1、html渲染过程 参考回答: 浏览器渲染页面是一个从上至下的过程，当拿到html以后首先会生成dom树，加载解析css构建cssom树，解析css的时候不会阻塞进程，我们通常会把首屏样式放到head里面，然后加载执行js，在js里面可能会有动态创建修改dom的逻辑，浏览器为了优化整个渲染过程，会在解析到js的时候阻塞整个进程，我们通常把js放到body后面来优化首屏的加载速度，当dom以及cssom都构建完成后会生成渲染树，再根据渲染树将dom树上的节点布局到屏幕上的正确位置，最后遍历绘制的所有节点，为其添加对应的样式 延伸理解重绘：改变dom的外观属性，如背景色，outline等重排: 改变dom的结构，几何属性等为了减少浏览器的重排重绘，我们应该将多次改变样式的操作合并成一次操作 2、HTTPS和HTTP的区别及优缺点 参考回答:1.http是超文本传输协议,信息是明文传输, https是具有安全性的ssl加密传输协议2.两者采用完全不同的连接方式，http连接是无状态的, https是由ssl＋http协议构建的可进行加密传输，身份认证的网络协议3.两者用的端口也不一样，前者80后者4434.https 需要证书优点https在seo以及安全性方面要高于http缺点https加载时间较长，证书收费 3、js中this 参考回答:js中this的指向总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的， 而非函数被声明时的环境具体到实际应用中，this 的指向大致可以分为以下几种*作为对象的方法调用指向当前对象*作为普通函数调用指向全局window*构造函数调用指向返回的对象*call,apply 调用指向其第一个参数 4、怎么理解js中是原型链? 如何实现继承? 参考回答:每个构造函数都有一个原型对象每个原型对象都包含一个指向构造函数的指针每个实例都包含一个指向原型对象的指针查找方式是一层层向上查找直至顶层Object.prototype实现继承的方式常用的有:原型链继承借用构造函数(call,apply)组合继承(原型链＋构造函数)原型式继承寄生式组合式继承延伸理解:优缺点?每一种继承的方式都有自己的优缺点组合继承的特点是会调用构造函数两次,都是将多种继承方式组合到一起相辅相成.new 运算符具体干了什么?创建一个空的对象将空的对象的__proto__成员指向构造函数的prototype成员对象调用构造函数将this指向前面创建的对象 5、怎么理解js中的内存泄漏? 参考回答:内存泄漏的定义为当程序不再需要的内存，由于某种原因其不会返回到操作系统或可用内存池，内存泄漏会导致一系列问题，比如: 运行缓慢，崩溃，高延迟等js中常见的内存泄露:意外的全局变量遗忘的计时器或回调函数脱离文档的DOM引用闭包 6、如何理解浏览器的跨域问题？常用的解决方式有哪些？ 参考回答:浏览器的同源策略会导致跨域，这里同源策略又分为以下两种 ：DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作注：协议、域名、端口有任何一个不同，都视为不同的域常用的解决方式:1.CORS(Cross-origin resource sharing) 跨域资源共享注: 这种方式如果想要携带cookie需要xhr设置withCredentials为true, 服务端 Access-Control-Allow-Credentials:true2.jsonp实现跨域(动态创建script,利用src属性进行跨域)3.服务器代理(浏览器有跨域限制，服务端没有)4.document.domain5.window.name6.hash传值7.possMessage 7、函数防抖，函数节流的基本概念以及工作中实际使用到的场景？实现的思路是？ 参考回答:函数防抖(debounce)基本概念: 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。举例理解: 我们用手指一直按住一个弹簧，它将不会马上弹起直到你松手为止使用场景:按钮重复点击输入框连续输入判断scroll是否滑到底部简单实现: 函数节流(throttle)基本概念: 在规定的时间范围内相同的操作触发多次只执行一次DOM拖拽Canvas画笔窗口resize简单实现: 8、js中的eventloop机制？ 参考回答:首先javascript是单线程机制，就是指当我们在执行一个任务的时候，其它的事情都得等待他执行完毕在js中所有任务分为两种, 同步任务及异步任务执行栈执行主线程任务，当有操作dom，ajax交互，使用定时器异步操作的时候，这些任务会被移入到 callback queue 任务队列中 当主线程任务执行完毕为空时，会读取callback queue队列中的函数，进入主线程执行 上述过程会不断重复，也就是常说的Event Loop(事件循环)在一个事件循环中,异步任务返回结果后会被扔进一个任务列队中，根据异步事件上的类型，这个事件会被放到对应的宏任务或者微任务列队中去， 当执行栈为空的时候，主线程会先查看微任务中的事件列队，如果微任务不是空先依次执行微任务，如果是空的再去宏任务列队中取出一个事件并把对应的回调加入到当前执行栈，如此反复，进入循环下面用一道题来加深印象 9、web安全攻击手段有哪些？以及如何防范 常见的有xss, csrf, sql注入xss(cross site scripting) 跨站脚本攻击定义: 指攻击者在网页嵌入脚本，用户浏览网页触发恶意脚本执行XSS攻击分为3类：存储型（持久型）、反射型（非持久型）、基于DOM如何防范:设置HttpOnly以避免cookie劫持的危险过滤，对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤编码，像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码限制，对于一些可以预期的输入可以通过限制长度强制截断来进行防御csrf(cross site request forgery) 跨站请求伪造定义: 是一种劫持受信任用户向服务器发送非预期请求的攻击方式如何防范:验证 HTTP Referer 字段请求地址中添加 token 并验证HTTP 头中自定义属性并验证sql注入(SQL injection)定义: 在未授权情况下，非法访问数据库信息如何防范:杜绝用户提交的参数入库并且执行在代码层，不准出现sql语句在web输入参数处，对所有的参数做sql转义上线测试，需要使用sql自动注入工具进行所有的页面sql注入测试 10、说说你对前端模块化的理解。 模块的定义:可以理解成实现特定功能的相互独立的一组方法为什么要使用模块化:可维护性命名空间可复用性模块化规范CommonJSAMDUMDCMDModule(es6)CommonJSCommonJS 扩展了JavaScript声明模块的API,通过CommonJS，每个JS文件独立地存储它模块的内容（就像一个被括起来的闭包一样）。在这种作用域中，我们通过 module.exports 语句来导出对象为模块，再通过 require 语句来引入如： AMD （Asynchronous Module Definition）特点:提倡依赖前置，在定义模块的时候就要声明其依赖的模块如： CMD (Common Module Definition)CMD规范是国内SeaJS的推广过程中产生的提倡就近依赖（按需加载），在用到某个模块的时候再去require UMD (Universal Module Definition)AMD和CommonJS的结合,跨平台的解决方案,UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块如： Module原生ＪＳ(es6)解决方案如: 11、Call，apply，bind的使用与区别，如何实现一个bind？ 相同点:都是使用于方法借用及明确this指向场景第一个参数都是this要指向的对象都可以利用后续参数传参不同点:参数传递方式不同call,apply是立即调用,bind是动态调用基本使用:Array.prototype.slice.call(obj,0,1,2)Array.prototype.slice.apply(obj,[0,1,2])Array.prototype.slice.bind(obj)(0,1,2)从上面的例子可以看出来call,apply 使用上几乎保持一致，而bind实际上是返回了一个函数简易bind实现 上面的bind只实现了方法的作用域绑定，参数已经固定，如果想要动态的参数我们得改写一下 12、前端的缓存有哪些？都适用什么场景？区别是什么？ 参考回答前端缓存分为两部分:http 缓存浏览器缓存http 缓存强缓存强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的Cache-Control 值理解:max-age 指定设置缓存最大的有效时间(单位为s)public 指定响应会被缓存，并且在多用户间共享private 响应只作为私有的缓存，不能在用户间共享no-cache 指定不缓存响应，表明资源不进行缓存no-store 绝对禁止缓存Expires 理解:缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点, 需要和Last-modified结合使用Last-modified 理解服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式ETag 理解根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改协商缓存(304)协商缓存是指当强缓存机制如果检测到缓存失效，就需要进行服务器再验证浏览器缓存CookieLocalStorageSessionStorageService WorkerCookieCookie主要用于用户信息的存储, 容量为4KBLocalStorageLocalStorage的数据将一直保存在浏览器内，直到用户清除浏览器缓存数据为止, 容量为5MBSessionStorageSessionStorage的其他属性同LocalStorage, 不同是的当页面关闭时会随之清除Service Worker主要是为了提高web app的用户体验，可以实现离线应用消息推送等等一系列的功能, 可以看做是一个独立于浏览器的Javascript代理脚本, 在离线状态下也能提供基本的功能。 出于安全性的考虑，Service Worker 只能在https协议下使用 13、Http常见状态码及其含义? http状态码分为5个大类1** 信息相关2** 请求成功3** 重定向相关4** 客户端错误相关，或无法完成请求5** 服务端错误相关301—永久移动。被请求的资源已被永久移动位置；302—请求的资源现在临时从不同的 URI 响应请求；305—使用代理。被请求的资源必须通过指定的代理才能被访问；307—临时跳转。被请求的资源在临时从不同的URL响应请求；400—错误请求；402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付；403—禁止访问。服务器已经理解请求，但是拒绝执行它；404—找不到对象。请求失败，资源不存在；406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体；408—请求超时；409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成；410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址；413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足；418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现；420—方法失效。422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应；500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理 14、前端优化手段有哪些？ 静态资源合并压缩(js,css, images)请求数量优化Gzip压缩带宽优化CDN就近节点，减少DNS查找按需加载lazyload减少请求骨架屏优化白屏web缓存缓存ajax数据减少重绘和重排批量更新ＤＯＭ样式页面结构将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 15、元素水平垂直居中的方式有哪些 absolute加margin方案fixed 加 margin 方案display:table 方案行内元素line-height方案flex 弹性布局方案transform 未知元素宽高解决方案 (1)、absolute加margin方案: (2)、fixed 加 margin 方案 (3)、display:table 方案 (4)、行内元素line-height方案 (5)、flex 弹性布局方案 (6)、transform 未知元素宽高解决方案 16、var let const的区别及使用场景 使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象，后面的覆盖前面的使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升, 不能重复声明使用const声明的是常量，在后面出现的代码中不能再修改该常量的内存 17、如何理解es6中的类？ 首先,JS作为一门非面向对象语言，在es6之前，并没有提供对类的支持，我们常用的做法是通过构造函数来模拟类的实现, 通过将属性及方法定义在原型上共享给其实例 ES6 中的Classes6中的class只是一个语法糖，class的写法只是让对象原型看起来更加清晰每个类中都有一个constructor方法，如果没有显示定义， 会默认添加一个空的constructor，等同于ES5中的构造函数, 类的所有方法都是定义在类的prototype属性上面，二者的主要区别在于Class必须使用new调用, ES5中构造函数不使用new也可以调用, class 中新增静态方法(static)关键字, 静态方法不能被继承只有通过类本身来调用 Extends 继承class 也可以通过extends 关键字实现继承extends 注意点使用extends 继承时，子类构造函数中必须调用super(), 代表调用父类的构造函数super虽然代码父类的constructor,但是返回的子类的实例super作为函数调用时，代表类的构造函数super作为对象调用时, 在普通方法中，指向父类的原型对象, 静态方法中指向父类 18、如何理解es6中的Promise？ 参考回答js是单线程的，也就是说一次只能完成一个任务，为了解决这个问题，js将任务的执行模式分为两种， 同步和异步, 在es5中我们处理异步只能通过的回调的方式进行处理，在多层异步中，回调会一层一层嵌套，也就是所谓的回调地狱，promise就是异步编程的一种解决方案 Promise特点:对象的状态不受外界影响, promise对象代表一个异步操作，有三种状态pendding(进行中), fulfilled(成功), rejected(失败)一旦状态改变，就不会再变, 状态的改变只有两种可能, pendding &#x3D;&gt; fulfilled及pendding &#x3D;&gt; rejected基本用法: promise 生成实例后可以使用then方法接收resolved状态和rejected状态的回调函数 promise原型上具有catch方法， catch方法是rejection的别名， 用于指定发生错误时的回调函数 promise原型上具有finally方法，用于不管promise对象最后的状态如何，都会执行的操作 Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例 特点:参数都是promise实例，如果不是会调用promise.resolve方法将其转为promise实例p的奖态由传入的promise实例的状态决定promise实例状态都变成fulfilled,p状态为fulfilledpromise实例状态一个变成rejected,p状态为rejected 19、如何理解es6中的Proxy？ Proxy（代理） 定义可以理解为为目标对象架设一层拦截，外界对该对象的访问，都必须通过这层拦截简单示例: 从上面的示例中可以看出，Proxy存在一种机制，可以对外界的读写操作进行改写Proxy 实例方法proxy除了代理get,set操作，还能代理其它的操作，如下 为什么要使用Proxy拦截和监视外部对对象的访问降低函数或类的复杂度在复杂操作前对操作进行校验或对所需资源进行管理 20、如何理解es6中的decorator？ 定义Decorator是ES7中的提案，概念借鉴于python， 它作用于一个目标类为其添加属性于方法我们用一个比喻来理解Decorator, 把孙悟空看成是一个类，那么棒子就是装饰器为其装备的武器代码理解: Decorator 不仅能修饰类，也能修饰类的方法 Decorator 只能修饰类及类的方法,不能修饰于函数,因为存在函数提升 Mixin在修饰器基础上，我们可以实现mixin(混入),意思在一个对象中混入另一个对象的方法代码示例: 使用Decorator的好处扩展功能，相对于继承增加了更多的灵活性代码可读性更高，装饰器正确命名相当于注释 21、Es6中新增的数据类型有哪些？使用场景？ es6中新增一种原始数据类型Symbol,最大的特点是唯一性，Symbol值通过Symbol函数生成, 在es5中对象的属性都是字符串，我们使用他人定义的对象，然后去新增自己的属性，这样容易起冲突覆盖原有的属性, Symbol也可以看成为一个字符串，不过这个字符能保证是独一无二的基本示例: Symbol用法Symbol 目前有多种写法 Symbol作为属性名，只有通过Object.getOwnPropertySymbols 方法返回 Symbol.for()如果我们想要重复Symbol可以使用Symbol.for， Smybol.for()及Smybol()的区别在于Symbol.for()会先去查找全局下有没有声明过，如果有就返回该值，没有就新建一个，Symbol()每一次调用都会新建一个代码理解: 总结Symbol的特点独一无二不能隐式转换不能与其它数据类型做运算不能使用点运算符进行操作ps: 今天答题的小伙伴多次都提到了map,set，，补充一下，新增的数据类型只有Symbol一种，map,set是新增的数据结构 _ 持续更新中…&amp;copy;lzccheng "},{"title":"vue进阶问题","date":"2022-04-22T04:09:27.000Z","url":"/blog/2022/04/22/vueInterview/","tags":[["javascript","/blog/tags/javascript/"],["干货","/blog/tags/%E5%B9%B2%E8%B4%A7/"],["vue","/blog/tags/vue/"]],"categories":[["javascript","/blog/categories/javascript/"]],"content":"1.为什么要使用vue？ 重点考察对vue的特性了解，三大框架的优缺点对比，以及跟传统操作dom的区别 2.vue有哪些生命周期及其使用场景？3.vue-router中keepalive怎么理解？ keep-alive是vue源码中实现的一个组件, 感兴趣的可以研究源码  什么是keepalive我们平时开发中, 总有部分组件没有必要多次init, 我们需要将组件进行持久化，使组件状态维持不变，在下一次展示时， 也不会进行重新initkeepalive音译过来就是保持活着, 所以在vue中我们可以使用keepalive来进行组件缓存基本使用 上面提到被keepalive包含的组件不会被再次init，也就意味着不会重走生命周期函数, 但是平常工作中很多业务场景是希望我们缓存的组件在再次渲染的能做一些事情,vue为keepalive提供了两个额外的hookactivated 当keepalive包含的组件再次渲染的时候触发deactivated 当keepalive包含的组件销毁的时候触发注: 2.1.0 版本后keepalive包含但被exclude排除的组件不会有以上两个hook参数keepalive可以接收3个属性做为参数进行匹配对应的组件进行缓存include 包含的组件exclude 排除的组件max 缓存组件的最大值其中include,exclude可以为字符，数组，以及正则表达式max 类型为字符或者数字代码理解 配合router使用 总结keepalive是一个抽象组件，缓存vnode，缓存的组件不会被mounted，为此提供activated 和 deactivated 钩子函数, 使用props max 可以控制缓存组件个数 4.Vue.use中都发生了什么？ 源码地址:  定义vue.use()往全局注入一个插件，供全局真接使用, 不需要单独引用代码理解: 理解了其基本使用及作用，我们来看一下vue.use中都发生了什么源码很少，所以直接摘抄了 结合代码理解 总结vue.use()为注册全局插件所用，接收函数或者一个包含install属性的对象为参数，如果参数带有install就执行install, 如果没有就直接将参数当install执行, 第一个参数始终为vue对象, 注册过的插件不会重新注册 5.New vue()中发生了什么？ 先从语法上分析，new关键字在js语言中代表实例化一个对象, 而Vue实际上是一个类, 我们简单看一下源码，源码地址  接着我们追踪至_init函数，源码地址  从上面的代码我们看见_init很清淅的干了几件事, 合并相关配置, 初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等题外话Vue初始化逻辑非常清淅，把不同的功能拆成一些单独的函数执行，这种思想值得借鉴和学习 6.Vue.js的template编译过程？7.Vue中的nextTick如何理解？ 讲在前面: 在vue中，数据发生变化之后DOM并不会立即变化，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新，代码理解 nextTick什么情况下会触发在同一事件循环中的数据变化后，DOM更新完成, 执行nextTick(callback)内的回调对事件循环不理解的可以点这里vue中nextTick的实现 ，源码地址  总结数据的变化到 DOM 的重新渲染是一个异步过程, 我们必须在 nextTick 后执行DOM相关的操作 8.Vue-router有哪些钩子？使用场景？ 前面我们用大白话讲过什么是钩子，这里在重复一下，就是在什么什么之前,什么什么之后,英文叫hooks,专业点叫生命周期，装逼点可以叫守卫…vue-router中也存在钩子的概念,分为三步记忆全局守卫路由独享守卫组件独享守卫全局守卫很好理解，全局守卫就是能监听到全局的router动作router.beforeEach 路由前置时触发组件独享守卫组件内新一个守卫, beforeRouteUpdate,在组件可以被复用的情况下触发，如 &#x2F;demo&#x2F;:id, 在&#x2F;demo&#x2F;1 跳转&#x2F;demo&#x2F;2的时候，&#x2F;demo 可以被复用，这时会触发beforeRouteUpdate 注意在beforeRouteEnter前不能拿到当前组件的this，因为组件还有被创建，我们可以通过next(vm &#x3D;&gt; {console.log(vm)}) 回传当前组件的this进行一些逻辑操作使用场景路由进入前最典型的可以做一些权限控制, 路由离开时清除或存储一些信息,任务等等总结vue-router中钩子分为全局的，局部的，以及组件三种形式, 他们都有前置守卫以及后置守卫, 其中组件的前置守卫不能拿到当前组件的this，因组件还没有被创建，可以通过next的参数进行回传this，前置守卫必须调用next方法，否则不会进入下一个管道 9.什么情况下适合使合vuex？ Vuex使用中有几个步骤? 持续更新中… "},{"title":"js基础面试题","date":"2022-04-22T04:04:06.000Z","url":"/blog/2022/04/22/jsInterview/","tags":[["javascript","/blog/tags/javascript/"],["干货","/blog/tags/%E5%B9%B2%E8%B4%A7/"]],"categories":[["javascript","/blog/categories/javascript/"]],"content":"1、undefined 和 null有什么区别？相同：它们是属于虚值，可以使用Boolean(value)或!!value将其转换为布尔值时，值为false区别：undefined：是未指定特定值的变量的默认值，或者函数默认返回值null：是“不代表任何值的值”。null是已明确定义给变量的值。 2、符号运算&amp;&amp;：可作为if短路运算，满足左边条件才执行右边语句||：可为变量赋值默认值+：快速将右边值转为数字类型!!：快速将右边值转为布尔值 3、什么是事件传播?事件传播有三个阶段：（1）捕获阶段：事件从 window 开始，然后向下到每个元素，直到到达目标元素。（2）目标阶段：事件已达到目标元素。（3）冒泡阶段：事件从目标元素冒泡，然后上升到每个元素，直到到达 window。 addEventListener方法具有第三个可选参数isCapture，默认值为false 当isCapture为false时，事件在冒泡阶段发生即从当前元素开始搜索并执行相同类型事件，直到window结束 当isCapture为true时，事件在捕获阶段发生即从window开始搜索并执行相同类型事件，直到当前元素4、event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？ event.preventDefault() ：阻止元素默认事件 vent.stopPropagation()：阻止事件传播（冒泡和捕获）5、event.target 和event.currentTarget的区别 event.target：当前触发事件的元素 event.currentTarget：当前绑定事件的元素6、== 和 === 有什么区别 ==：一般比较，会转换后比较，比较值 ===：严格比较，比较类型和值，类型和值其中一个不同即为false7、什么是作用域？JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：全局作用域、函数作用域和块作用域(ES6)。 全局作用域：在全局命名空间中声明的变量或函数位于全局作用域中，因此在代码中的任何地方都可以访问它们。 函数作用域：在函数中声明的变量、函数和参数可以在函数内部访问，但不能在函数外部访问。 块作用域：在块{}中声明的变量（let，const）只能在其中访问。 作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为作用域链。 8、什么是提升？提升：是用来描述变量和函数移动到其(全局或函数)作用域顶部的术语 为了理解提升，需要来了解一下执行上下文。执行上下文是当前正在执行的“代码环境”。执行上下文有两个阶段:编译和执行。编译：在此阶段，JS 引荐获取所有函数声明并将其提升到其作用域的顶部，以便我们稍后可以引用它们并获取所有变量声明（使用var关键字进行声明），还会为它们提供默认值：undefined。执行：在这个阶段中，它将值赋给之前提升的变量，并执行或调用函数(对象中的方法)。 注意：只有使用var声明的变量，或者函数声明才会被提升，相反，函数表达式或箭头函数，let和const声明的变量，这些都不会被提升。9、什么是闭包？闭包就是一个函数在声明时能够记住当前作用域、父函数作用域、及父函数作用域上的变量和参数的引用，直至通过作用域链上全局作用域，基本上闭包是在声明函数时创建的作用域。10、JavaScript 中的虚值是什么？ 简单的来说虚值就是是在转换为布尔值时变为 false 的值。11、’use strict’ 是干嘛用的？“use strict” 是 ES5 特性，它使我们的代码在函数或整个脚本中处于严格模式。严格模式帮助我们在代码的早期避免 bug，并为其添加限制。严格模式的一些限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性deleteglobal[prop] eval不能在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。12、JavaScript 中 this 值是什么？this指的是当前正在执行或调用该函数的对象的值。this值的变化取决于我们使用它的上下文和我们在哪里使用它。 箭头函数没有自己的 this apply和call可以改变this的指向 在全局作用域内声明的函数，对象内部方法中的匿名函数和内部函数的this具有默认值，该值指向window对象。13、什么是 IIFE，它的用途是什么？IIFE或立即调用的函数表达式是在创建或声明后将被调用或执行的函数。创建IIFE的语法是，将function (){}包裹在在括号()内，然后再用另一个括号()调用它，如：(function(){})() IIFE的一个主要作用是避免与全局作用域内的其他变量命名冲突或污染全局命名空间14、call、apply、bind的区别call和apply：调用一个指定this值的函数，call传的是参数列表，apply传的是数组bind：创建一个新的函数并指定this值，传参和call都是参数列表15、arguments 的对象是什么？arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，如：forEach、reduce、filter和map 可以使用Array.prototype.slice将arguments对象转换成一个数组 箭头函数中没有arguments对象。16、ES6或ECMAScript 2015有哪些新特性？ 箭头函数 类 模板字符串 加强的对象字面量 对象解构 Promise 生成器 模块 Symbol 代理 Set 函数默认参数 rest 和展开 块作用域17、var,let和const的区别是什么？ 全局作用域下var声明的变量会挂载在window上，而let和const声明的变量不会 var声明变量存在变量提升，let和const不存在变量提升 let和const声明形成块作用域 同一作用域下let和const不能声明同名变量，而var可以 暂存死区 const 一旦声明必须赋值,不能使用null占位。 声明后不能再修改 如果声明的是复合类型数据，可以修改其属性 18、什么是箭头函数？ 箭头函数表达式的语法比函数表达式更简洁 没有自己的this，arguments，super或new.target 不能用作构造函数19、什么是类？类(class)是在 JS 中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。20、什么是 ES6 模块？ es5 commonjs：module.exports&#x2F;exports[prop]导出，require导入 es6 模块：export default&#x2F;export 导出，import导入21、什么是Set对象，它是如何工作的？Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用 add方法：向Set实例中添加一个新值 has方法：检查Set实例中是否存在特定的值。 size属性：获得Set实例的长度 clear方法：清楚Set实例的数据 由于存储的是唯一值，传入数组，可以对数组去重22、Promise 是什么？promise是异步编程的一种解决方案，从语法上讲，promise是一个对象有三种状态，状态一旦改变，就不会再变 pending(等待态） fulfiled(成功态) rejected(失败态) 创造promise实例后，它会立即执行。 23、什么是 async/await 及其如何工作？async&#x2F;await是 JS 中编写异步或非阻塞代码的新方法。它建立在Promises之上，让异步代码的可读性和简洁度都更高。 使用 async关键声明函数会隐式返回一个Promise await关键字只能在async function中使用。在任何非async function的函数中使用await关键字都会抛出错误。await关键字在执行下一行代码之前等待右侧表达式(可能是一个Promise)返回。24、展开(spread )运算符和 剩余(Rest) 运算符有什么区别？ 25、什么是包装对象（wrapper object）？JS数据类型被分为两大类，基本类型和引用类型。 基本类型：Undefined,Null,Boolean,Number,String,Symbol,BigInt 引用类型：Object,Array,Date,RegExp等，说白了就是对象。 除null和undefined之外的每个基本类型都有自己包装对象。 26、什么是NaN？以及如何检查值是否为NaN？NaN表示“非数字”是 JS 中的一个值，该值是将数字转换或执行为非数字值的运算结果，因此结果为NaN 在 JS 中，NaN是唯一的值，它不等于自己 JS 有一个内置的isNaN方法，用于测试值是否为isNaN值，但是这个函数有一个奇怪的行为，建议使用Number.isNaN 可以使用自己的辅助函数： 27、如何检查对象中是否存在某个属性 使用in操作符，包括原型上的属性 hasOwnProperty 方法：对象自身的属性，不包括原型上的 obj[pro]为undefined则不存在28、函数表达式和函数声明之间有什么区别？函数声明会将函数提升到作用域的顶部，函数表达式不会 29、new 关键字有什么作用？new关键字做了4件事: 创建空对象 &#123;&#125; 将空对象分配给 this 值 将空对象的proto指向构造函数的prototype 如果没有使用显式return语句，则返回this 看下面事例： 根据上面描述的，new Person()做了： 创建一个空对象：var obj = &#123;&#125; 将空对象分配给 this 值：this = obj 将空对象的proto__指向构造函数的prototype：this.__proto = Person().prototype 返回this: return this "},{"title":"前端干货","date":"2022-04-22T03:57:19.000Z","url":"/blog/2022/04/22/good/","tags":[["javascript","/blog/tags/javascript/"],["干货","/blog/tags/%E5%B9%B2%E8%B4%A7/"]],"categories":[["javascript","/blog/categories/javascript/"]],"content":"技能面试题：高级程序设计第4版.pdf每天往前一小步"},{"title":"flutter填坑记","date":"2022-04-21T09:45:15.000Z","url":"/blog/2022/04/21/flutterProblem/","tags":[["flutter","/blog/tags/flutter/"],["dart","/blog/tags/dart/"]],"categories":[["flutter","/blog/categories/flutter/"]],"content":"1、environment: sdk: “&gt;&#x3D;2.12.0 &lt;3.0.0”该版本默认开启了空安全校验假如有包不支持空安全在flutter run时会报错： Cannot run with sound null safety, because the following dependencies don’t support null safety 解决方案： 增加参数： –no-sound-null-safety 2、图片路径配置时，只支持当前文件夹下的图片，读取不到子文件夹的图片 3、bottomNavigationBar设置4个及更多会变白色 解决方案： BottomNavigationBar的type设置BottomNavigationBarType.fixed 4、AppBar的titleTextStyle不生效 解决方案： AppBar设置backwardsCompatibility: false, 5、AppBar的leading换行 解决方案： AppBar设置leadingWidth: 200 6、http中文乱码 解决方案： 7、http的headers加上’content-type’: ‘application&#x2F;json;charset&#x3D;UTF-8’时需要对post请求body进行jsonEncode 解决方案： 8、主题色primarySwatch接收的是MaterialColor，自定义16进制颜色需要自己实现转换返回MaterialColor 解决方案： 9、http拦截需要无context转跳 解决方案： 利用GlobalKey绑定在MaterialApp的navigatorKey上进行转跳代码： "},{"title":"快速搭建博客","date":"2022-04-21T08:26:16.000Z","url":"/blog/2022/04/21/buildBlog/","tags":[["快速搭建博客","/blog/tags/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"],["教程文档","/blog/tags/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"categories":[["教程文档","/blog/categories/%E6%95%99%E7%A8%8B%E6%96%87%E6%A1%A3/"]],"content":"现成框架hexo文档地址：、安装hexo-cli 2、创建项目 生成的是默认的主题，可自行更换主题， 3、生成新文章 即可生成新文章，可在source目录下找到对应title名字的md文件，自行编辑即可，想了解更详细可访问文档 4、把博客放到GitPage 1）、修改_config.yml的url为gitpage的url 2）、把img的url改成相对路径 md文件顶部基本属性： 推荐主题： 该主题自带鼠标点击效果 "},{"title":"flutter","date":"2022-04-21T08:07:38.000Z","url":"/blog/2022/04/21/flutter/","tags":[["flutter","/blog/tags/flutter/"],["dart","/blog/tags/dart/"]],"categories":[["flutter","/blog/categories/flutter/"]],"content":"基础入门dart：类型： num、int、double、String、void、dynamic、set、list、map（Numbers、Strings、Booleans、Lists、Sets、Maps、Runes、Symbels、null）定义变量： var、const、final字符串插值： $变量、$&#123;变量&#125;?./??/泛型/minxins、 空安全：1、可空（?）类型的使用： 我们可以通过将?跟在类型的后面来表示它后面的变量或参数可接受Null： 对于可空的变量或参数在使用的时候需要通过Dart 的避空运算符?.来进行访问，否则会抛出编译错误。2、当程序启用空安全后，类的成员变量默认是不可空的，所以对于一个非空的成员变量需要指定其初始化方式： 3、延迟初始化（late）的使用对于无法在定义时进行初始化，并且又想避免使用?.，那么延迟初始化可以帮到你。通过late修饰的变量，可以让开发者选择初始化的时机，并且在使用这个变量时可以不用?.。 延时初始化虽然能为我们编码带来一定便利，但如果使用不当会带来空异常的问题，所以在使用的时候一定保证赋值和访问的顺序，切莫颠倒。4、State的空安全适配State的空安全适配主要是根据它的成员变量是否可空进行分类： 可空的变量：通过?进行修饰不可空的变量：可采用以下两种方式进行适配定义时初始化使用late修饰为延时变量 flutter 组件库： 中文书：  功能例子： 组件： 属性： &#x3D;&#x3D;&#x3D;状态组件： &#x3D;&#x3D;&#x3D;布局相关组件 &#x3D;&#x3D;&#x3D;app组件： &#x3D;&#x3D;&#x3D;页面组件： &#x3D;&#x3D;&#x3D;顶部导航： &#x3D;&#x3D;&#x3D;span： &#x3D;&#x3D;&#x3D;button: &#x3D;&#x3D;&#x3D; form表单： 表单提交： Image swiper: flex: flutter路由： fluter 事件 图片资源 打开第三方App 生命周期 &#x2F;&#x2F; 应用生命周期进入前台进入后台挂起 动态修改主题 自定义字体 选择手机图片 使用包： image_picker &#x2F;&#x2F; 需要兼容Android X配置 轮播swiper http网络请求 使用包： http、dart:convert 异步： Future、FutureBuilder 加载中…loading Widget: CircularProgressIndicator shared_preferences本地存储 Toast 提示 解决中文乱码 ListView 水平滚动 下拉刷新上拉加载功能 上拉加载： ExpansionTile展开收起效果组件 GridView 网格布局 复制到粘贴板 uri转义空格、&amp;、#等 时间 DateTime 时间选择 showDatePicker 返回DateTime 时间范围选择 showDateRangePicker返回DateRangerTime取start和end属性是DateTime类型 toast、loading包： flutter_easyloading lading组件包： m_loading、flutter_spinkit 中文配置 手机语言设置成中文即可显示中文 页面缓存 屏幕适配 flutter_screenutil table只加内部边框，用Container包一下可以给table加上borderRadius drawer 侧边弹出框 表单 多选框 下拉框 输入框 flutter_picker 选择器 base46图片 dart 定时器 "}]